--Section A – Core PL/SQL (100 Marks)
--Note: These tasks assess core PL/SQL skills including procedure writing, cursors, triggers, exception handling,
--and transactions.

--1. Procedure – Fund Transfer (20 Marks)
--Write a procedure transfer_funds(p_from_acct IN VARCHAR2, p_to_acct IN VARCHAR2, p_amount IN
--NUMBER) to transfer funds between two accounts. Ensure:
--- Validation: Both accounts exist.
--- Sufficient balance.
--- Atomic transaction with rollback on failure.

CREATE OR REPLACE PROCEDURE TRANSFER_FUNDS
(P_FROM_ACCOUNT IN VARCHAR2, P_TO_ACCOUNT IN VARCHAR2, P_AMOUNT IN NUMBER) 

AS

V_AMOUNT NUMBER(10,2);
V_FROM_ACCOUNT VARCHAR2(10);
V_TO_ACCOUNT VARCHAR2(10);

BEGIN

SELECT ACCOUNT_NUMBER, BALANCE INTO V_FROM_ACCOUNT, V_AMOUNT
FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;

SELECT ACCOUNT_NUMBER, BALANCE INTO V_TO_ACCOUNT, V_AMOUNT FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;


IF V_FROM_ACCOUNT > 0 AND V_AMOUNT > 0 THEN 

UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE - P_AMOUNT 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;
 
 COMMIT;
 
 DBMS_OUTPUT.PUT_LINE('WITHDRAWAL SUCCESSFUL.');
 
 ELSE
 
 ROLLBACK;
 
 END IF;
 
 
 IF V_TO_ACCOUNT > 0 THEN 
 
 UPDATE BANK_ACCOUNTS
 SET BALANCE = BALANCE + P_AMOUNT
 WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 COMMIT;
 
  DBMS_OUTPUT.PUT_LINE('YOUR ACCOUNT WAS SUCCESSFULLY CREDITED');

 ELSE
 
 ROLLBACK;

 END IF;
 
 
 EXCEPTION

 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('ACCOUNT NOT FOUND');
 WHEN OTHERS THEN
 DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR!'||SQLERRM);
 END;
 /



--2. Function – Account Summary (10 Marks)
--Create a function get_account_summary(p_acct_no IN VARCHAR2) RETURN VARCHAR2 that returns a string
--summary of account name and balance.

CREATE OR REPLACE FUNCTION GET_ACCOUNT_SUMMARY(P_ACCT_NO IN VARCHAR2)
RETURN VARCHAR2
AS
V_ACCOUNT_SUMMARY NUMBER;
V_ACCOUNT_NAME VARCHAR2(100); 
V_ACCOUNT_NUMBER VARCHAR2(100);
V_BALANCE NUMBER(10,2);

BEGIN

SELECT ACCOUNT_NAME, BALANCE INTO V_ACCOUNT_NAME, V_BALANCE FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = V_ACCOUNT_NUMBER;

V_ACCOUNT_SUMMARY := V_ACCOUNT_NUMBER ||  V_BALANCE;

DBMS_OUTPUT.PUT_LINE(V_ACCOUNT_SUMMARY);

RETURN V_ACCOUNT_SUMMARY;

END;

/
--3. Cursor – Calculate Interest (15 Marks)
--Use an explicit cursor to iterate through accounts and increase their balance by 5% interest. Use a FOR LOOP
--and UPDATE statement.

DECLARE 

V_ACCOUNT_NUMBER BANK_ACCOUNTS.ACCOUNT_NUMBER%TYPE;
V_BALANCE BANK_ACCOUNTS.BALANCE%TYPE;



CURSOR C1 IS 
SELECT ACCOUNT_NUMBER, BALANCE FROM BANK_ACCOUNTS
WHERE BANK_ACCOUNTS = V_ACCOUNT_NUMBER;


BEGIN 
FOR  i IN  C1 LOOP
IF i > 0 THEN
UPDATE BANK_ACCOUNT
SET BALANCE = BALANCE + BALANCE*0.05
WHERE ACCOUNT_NUMBER = V_ACCOUNT_NUMBER;

DBMS_OUTPUT.PUT_LINE('ACCOUNT UPDATED SUCCESSFULLY!');
END IF;

END LOOP;

EXCEPTION 
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR'||SQLERRM);

END;
/



--4. Trigger – Audit Transactions (20 Marks)
--Write a trigger trg_audit_transaction that captures any UPDATE on balance and inserts into a table
--account_audit_log(account_number, old_balance, new_balance, modified_on).

CREATE TABLE ACCOUNT_AUDIT_LOG(
ACCOUNT_NUMBER VARCHAR2(10) PRIMARY KEY,
OLD_BALANCE NUMBER(10,2),
NEW_BALANCE NUMBER(10,2),
MODIFIED_ON DATE
);


CREATE OR REPLACE TRIGGER TRG_AUDIT_TRANSACTION
BEFORE UPDATE OF BALANCE ON BANK_ACCOUNTS
FOR EACH ROW 
DECLARE 
V_BALANCE NUMBER(10,2);

BEGIN
IF INSERTING THEN
INSERT INTO BANK_ACCOUNTS VALUES(:NEW.ACCOUNT_NUMBER, :NEW.OLD_BALANCE, 'INSERTED', SYSDATE);

ELSIF UPDATING THEN
INSERT INTO BANK_ACCOUNT VALUES(:OLD.ACCOUNT_NUMBER, :NEW.OLD_BALANCE, 'UPDATED', SYSDATE);
END IF;
END;


--5. Exception Handling – Minimum Balance Check (15 Marks)
--Write a procedure withdraw(p_account_no IN VARCHAR2, p_amount IN NUMBER) that throws a custom
--exception if the remaining balance goes below 1000.

CREATE OR REPLACE PROCEDURE MINIMUM_BALANCE_CHECK(P_ACCOUNT_NUMBER IN VARCHAR2, P_AMOUNT IN NUMBER)
AS

V_ACCOUNT_NUMBER VARCHAR2(100);
V_AMOUNT NUMBER;

BEGIN

SELECT ACCOUNT_NUMBER, BALANCE INTO V_ACCOUNT_NUMBER, V_AMOUNT FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

IF V_ACCOUNT_NUMBER > 0 AND V_AMOUNT <= 1000 THEN

DBMS_OUTPUT.PUT_LINE('YOU ACCOUNT BALANCE IS TOO LOW FOR WITHDRAWAL' || V_AMOUNT);

END IF;

EXCEPTION 

WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR: '|| SQLERRM);
END;
/

DECLARE

V_ACCOUNT_NUMBER VARCHAR2(10);
V_AMOUNT NUMBER(10,2);

BEGIN

MINIMUM_BALANCE_CHECK('ACC001', 2000 );

DBMS_OUTPUT.PUT_LINE('YOUR ACCOUNT BALANCE IS TOO LOW TO MAKE A WITHDARWAL');

END;
/


--6. Conceptual Questions (20 Marks)
--- What is the difference between %ROWTYPE and %TYPE?

---THE %ROWTYPE CONTAINS THE ENTIRE DATATYPE OF THE ROW RECORD AND 
--THE %TYPE IS JUST FOR A SINGLE RECORD OF AN ATTRIBUTE 


--- What is the purpose of AUTONOMOUS_TRANSACTION?

--STORED PROCEDURES AND FUNCTIONS ARE EXAMPLES OF AUTONOMOUS FUNCTIONS 
--AS THE NAME IMPLIES THERE ARE INDEPENDENT OF MAKING TRANSACTIONS. IF ANOTHER TRANSACTION CALLS AN
--AUTONOMOUS TRANSACTION IS IT IS NOT AFFECTED BY IT BECAUSE ONLY COMMITTED TRANSACTIONS CAN INTERACT.

--- Explain SAVEPOINT and ROLLBACK TO SAVEPOINT.

--SAVE POINTS ARE LOGICAL POINTS WITHIN A STATEMENT THAT A TRANSACTION ROLL'S BACK TO 
 -- ROLLBACK TO SAVEPOINTS ROLLBACK THE TRANSACTION TO THE PREVIOUS SSAVE POINTS
 
--- Difference between IN, OUT, and IN OUT parameters?

--IN IS A DEFAULT MODE PASSES VALUE TO THE SUBPROGRAM
--IS PASSED BY REFERENCE - NOT DIRECTLY

--OUT IS SPECIFIC, IT MUST BE SPECIFIED, SAME AS IN OUT

--IN OUT FIRST PASSES A VALUE TO THE SUBPROGRAM AND THEN 
--AND UPDATED VALUE TO THE CALLER 