--Section A – Core PL/SQL (100 Marks)
--Note: These tasks assess core PL/SQL skills including procedure writing, cursors, triggers, exception handling,
--and transactions.

--1. Procedure – Fund Transfer (20 Marks)
--Write a procedure transfer_funds(p_from_acct IN VARCHAR2, p_to_acct IN VARCHAR2, p_amount IN
--NUMBER) to transfer funds between two accounts. Ensure:
--- Validation: Both accounts exist.
--- Sufficient balance.
--- Atomic transaction with rollback on failure.

CREATE OR REPLACE PROCEDURE TRANSFER_FUNDS
(P_FROM_ACCOUNT IN VARCHAR2, P_TO_ACCOUNT IN VARCHAR2, P_AMOUNT IN NUMBER, P_MSG OUT VARCHAR2) 

AS

V_BALANCE NUMBER(10,2);
V_FROM_ACCOUNT VARCHAR2(10);
V_TO_ACCOUNT VARCHAR2(10);
V_MSG VARCHAR2(100);
V_TO_COUNT NUMBER;
V_FROM_COUNT NUMBER;


BEGIN

SELECT COUNT(*)INTO V_FROM_COUNT FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;

SELECT BALANCE INTO V_BALANCE
FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;


IF V_FROM_COUNT > 0 AND V_BALANCE > 0 THEN 

UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE - P_AMOUNT 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;
--COMMIT;

V_BALANCE := V_BALANCE - P_AMOUNT;

P_MSG := 'AN AMOUNT OF' ||V_BALANCE|| 'HAS BEEN DEDUCTED FROM YOUR ACCOUNT.';
 
COMMIT; 
 
ELSE 

ROLLBACK;

P_MSG := 'CURRENT BALANCE IS: '||V_BALANCE;

END IF;

 
SELECT COUNT(*)INTO V_TO_COUNT FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 
 SELECT BALANCE INTO V_BALANCE 
FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 
  IF V_TO_COUNT> 0  THEN 
 
 UPDATE BANK_ACCOUNTS
 SET BALANCE = BALANCE + P_AMOUNT
 WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 COMMIT;
 
  P_MSG := 'YOUR ACCOUNT WAS SUCCESSFULLY CREDITED';
  
  ELSE
  
  ROLLBACK;

 END IF;
 
 
 EXCEPTION

 WHEN NO_DATA_FOUND THEN
 P_MSG := 'ACCOUNT NOT FOUND';
 WHEN OTHERS THEN
 P_MSG := 'UNEXPECTED ERROR!'||SQLERRM;
 END;
 /
 
 DECLARE 
 
 V_FROM_ACCOUNT VARCHAR(20);
 V_TO_ACCOUNT VARCHAR2(10);
 V_AMOUNT NUMBER;
 V_MSG VARCHAR2(100);
 
 
 BEGIN
 
 TRANSFER_FUNDS
('ACC002', 'ACC001', 500, V_MSG);

DBMS_OUTPUT.PUT_LINE(V_MSG);

END;
/



--SELECT * FROM BANK_ACCOUNTS;



--2. Function – Account Summary (10 Marks)
--Create a function get_account_summary(p_acct_no IN VARCHAR2) RETURN VARCHAR2 that returns a string
--summary of account name and balance.

CREATE OR REPLACE FUNCTION GET_ACCOUNT_SUMMARY(P_ACCOUNT_NUMBER IN VARCHAR2)
RETURN VARCHAR2
AS
V_ACCOUNT_SUMMARY VARCHAR(100);
V_ACCOUNT_NAME VARCHAR2(100); 
V_ACCOUNT_NUMBER VARCHAR2(100);
V_BALANCE NUMBER(10,2);

BEGIN

SELECT ACCOUNT_NUMBER, ACCOUNT_NAME, BALANCE INTO V_ACCOUNT_NUMBER, 
V_ACCOUNT_NAME, V_BALANCE FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

V_ACCOUNT_SUMMARY := V_ACCOUNT_NUMBER ||'  '|| V_ACCOUNT_NAME ||'  '|| V_BALANCE;

--DBMS_OUTPUT.PUT_LINE(V_ACCOUNT_SUMMARY);

RETURN V_ACCOUNT_SUMMARY;

END;

/



DECLARE

V_ACCOUNT_SUMMARY VARCHAR2(100);

BEGIN
V_ACCOUNT_SUMMARY := GET_ACCOUNT_SUMMARY('ACC001');

DBMS_OUTPUT.PUT_LINE(V_ACCOUNT_SUMMARY);
END;
/


--3. Cursor – Calculate Interest (15 Marks)
--Use an explicit cursor to iterate through accounts and increase their balance by 5% interest. Use a FOR LOOP
--and UPDATE statement.


Declare
Cursor int_cursor is 
select  account_number, balance from bank_accounts;

bank_interest  bank_accounts%rowtype;

begin
 
 FOR bank_interest in int_cursor LOOP
    select count(*)into v_account from bank_accounts
    where account_number = bank_interest.Account_number;
    
    if v_account > 0 then
    update bank_accounts
    set balance = balance + balance * 0.05;
    dbms_output.put_line('Account '||bank_interest.Account_number|| ' exists. ');
    else
    dbms_output.put_line('Account '||bank_interest.Account_number|| ' does not exists. ');
    end if;
    end loop;
    end;
    /


DECLARE 

CURSOR BANK_INTEREST IS 
SELECT ACCOUNT_NUMBER, BALANCE FROM BANK_ACCOUNTS;


V_ACCOUNT_NUMBER  BANK_ACCOUNTS.ACCOUNT_NUMBER%TYPE;
V_BALANCE   BANK_ACCOUNTS.BALANCE%TYPE;

--V_COUNT NUMBER;

BEGIN 
FOR  BANK_REC IN  BANK_INTEREST LOOP

--SELECT COUNT(*) INTO V_COUNT FROM BANK_ACCOUNTS
--WHERE ACCOUNT_NUMBER = BANK_REC.ACCOUNT_NUMBER;

--IF V_COUNT > 0 THEN

UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE + BALANCE*0.05
WHERE ACCOUNT_NUMBER = BANK_REC.ACCOUNT_NUMBER;

DBMS_OUTPUT.PUT_LINE('ACCOUNT UPDATED SUCCESSFULLY!');

END LOOP;

EXCEPTION 
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR'||SQLERRM);

END;
/

--SELECT * FROM BANK_ACCOUNTS

--4. Trigger – Audit Transactions (20 Marks)
--Write a trigger trg_audit_transaction that captures any UPDATE on balance and inserts into a table
--account_audit_log(account_number, old_balance, new_balance, modified_on).

CREATE TABLE ACCOUNT_AUDIT_LOG(
ACCOUNT_NUMBER VARCHAR2(10) PRIMARY KEY,
OLD_BALANCE NUMBER(10,2),
NEW_BALANCE NUMBER(10,2),
MODIFIED_ON DATE
);


CREATE OR REPLACE TRIGGER TRG_AUDIT_TRANSACTION
BEFORE UPDATE OF BALANCE ON BANK_ACCOUNTS
FOR EACH ROW 
DECLARE 
V_BALANCE NUMBER(10,2);


BEGIN
IF INSERTING THEN
INSERT INTO ACCOUNT_AUDIT_LOG(ACCOUNT_NUMBER, OLD_BALANCE, NEW_BALANCE, MODIFIED_ON)
VALUES(:NEW.ACCOUNT_NUMBER, NULL, :NEW.BALANCE, SYSDATE);

ELSIF UPDATING THEN
INSERT INTO ACCOUNT_AUDIT_LOG (ACCOUNT_NUMBER, OLD_BALANCE, NEW_BALANCE, MODIFIED_ON)
VALUES(:OLD.ACCOUNT_NUMBER, :OLD.BALANCE, :NEW.BALANCE, SYSDATE);
END IF;

EXCEPTION

WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR!' || SQLERRM);
END;


--5. Exception Handling – Minimum Balance Check (15 Marks)
--Write a procedure withdraw(p_account_no IN VARCHAR2, p_amount IN NUMBER) that throws a custom
--exception if the remaining balance goes below 1000.

CREATE OR REPLACE PROCEDURE MINIMUM_BALANCE_CHECK(P_ACCOUNT_NUMBER IN VARCHAR2, P_AMOUNT IN NUMBER)
AS

V_ACCOUNT_NUMBER VARCHAR2(100);
V_AMOUNT NUMBER;
V_COUNT NUMBER;

BEGIN

SELECT ACCOUNT_NUMBER, BALANCE INTO V_ACCOUNT_NUMBER, V_AMOUNT FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

SELECT COUNT(*)INTO V_COUNT FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

IF V_COUNT > 0 AND V_AMOUNT <= 1000 THEN

DBMS_OUTPUT.PUT_LINE('YOU ACCOUNT BALANCE IS TOO LOW FOR WITHDRAWAL' || V_AMOUNT);

END IF;

EXCEPTION 

WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR: '|| SQLERRM);
END;
/

DECLARE

V_ACCOUNT_NUMBER VARCHAR2(10);
V_AMOUNT NUMBER(10,2);

BEGIN

MINIMUM_BALANCE_CHECK('ACC001', 2000 );

DBMS_OUTPUT.PUT_LINE('YOUR ACCOUNT BALANCE IS TOO LOW TO MAKE A WITHDARWAL');

END;
/


--6. Conceptual Questions (20 Marks)
--- What is the difference between %ROWTYPE and %TYPE?

--IN THIS EXERCISE, THE CURSOR VARIABLE BANK_REC USES A %ROWTYPE INSTANCE OF A DATATYPE
--AND OTHER LOCAL VARIABLES THAT TAKES IN THE PARAMETERIZED INPUT 
--ASSIGNED TO THEM HAVE THE %TYPE DATATYPE. IT HELPS IN MAINTAINING THE INTEGRITY OF THE DATABASE

---THE %ROWTYPE CONTAINS THE ENTIRE DATATYPE OF THE ROW RECORD AND 
--THE %TYPE IS JUST FOR A SINGLE RECORD OF AN ATTRIBUTE 
--AN EXAMPLE OF THE ROWTYPE IS FOR EXAMPLE THE EMPLOYEES TABLE. IT COVERS THE 
--DATATYPE OF THE EMPLOYEE ID, FIRST NAME, LAST NAME ETC AND IF I WOULD LATER CREATE ANOTHER 
--TABLE I WOULDNT NEED TO DECLARE THE ENTIRE THING AGAIN, I WOULD SIMPLE USE THE %ROWTYPE
--EXAMPLE    v_employee employees%ROWTYPE;


--THE %TYPE ONLY HOLDS THE TYPE FOR A PARTICULAR ATTRIBUTE AND NOT A RECORD. 
-- FOR EXAMPLE V_ACCOUNT_NUMBER BANK_ACCOUNTS.ACCOUNT_NUMBER%TYPE


--- What is the purpose of AUTONOMOUS_TRANSACTION?

--STORED PROCEDURES AND FUNCTIONS ARE EXAMPLES OF AUTONOMOUS FUNCTIONS 
--AS THE NAME IMPLIES THERE ARE INDEPENDENT OF MAKING TRANSACTIONS. IF ANOTHER TRANSACTION CALLS AN
--AUTONOMOUS TRANSACTION IS IT IS NOT AFFECTED BY IT BECAUSE ONLY COMMITTED TRANSACTIONS CAN INTERACT.
--EXAMPLE A CHILD CODE RUNNING INDEPENDENTLY OF THE PARENT CODE 

--IF WE WANT TRANSACTIONS TO BE INDEPENDENT AND NOT BE AFFECT BY COMMITS OR ROLLBACKS FROM OTHER 
--TRANSACTIONS, IT IS BEST TO USE AUTONOMOUS TRANSACTION. IT KEEPS A TRANSACTION FROM EXTERNAL INFLUENCES


--- Explain SAVEPOINT and ROLLBACK TO SAVEPOINT.

--SAVE POINTS ARE LOGICAL POINTS WITHIN A STATEMENT THAT A TRANSACTION ROLL'S BACK TO 
 -- ROLLBACK TO SAVEPOINTS ROLLBACK THE TRANSACTION TO THE PREVIOUS SSAVE POINTS
 
 --IF I MAKE THREE INSERT STATEMENTS AND THEN SAVE TRANSACTIONS, THAT IS A SAFEPOINT
 --IF I AGAIN INSERT THREE RECORDS AND AND SAVE IT, AND IF I ROLLBACK, IT TAKE, IT BACK TO 
 --FIRST THREE RECORD THAT WAS INSERTED. THIS SAVE TRANSACTION POINTS ARE VERY IMPORTANT WHEN.
 --IT HELPS TO MAINTAIN THE ACID PROPERTY OF A DATABASE 
 
--- Difference between IN, OUT, and IN OUT parameters?

--IN IS A DEFAULT MODE PASSES VALUE TO THE SUBPROGRAM
--IS PASSED BY REFERENCE - NOT DIRECTLY

--OUT IS SPECIFIC, IT MUST BE SPECIFIED, SAME AS IN OUT

--IN OUT FIRST PASSES A VALUE TO THE SUBPROGRAM AND THEN 
--AND UPDATED VALUE TO THE CALLER 











--Section B – APEX_JSON Tasks (50 Marks)
--Note: These tasks assess knowledge of handling JSON data using APEX_JSON package.
--7. Consuming JSON Input to Create Multiple Accounts (15 Marks)
--Write a procedure create_accounts_from_json(p_json IN CLOB) that parses a JSON array of account records
--using APEX_JSON and inserts them into bank_account table.
--Sample Input JSON:
--[
--{"account_number": "ACC010", "account_name": "Sandra George", "balance": 2000},
--{"account_number": "ACC011", "account_name": "Michael Bright", "balance": 1500}
--]

    CREATE OR REPLACE PROCEDURE CREATE_ACCOUNTS_FROM_JSON(P_JSON IN CLOB) IS 
    
      V_ACCOUNT_NUMBER VARCHAR2(10);
      V_ACCOUNT_NAME VARCHAR2(100);
      V_BALANCE NUMBER;
      
      BEGIN
        --PARSE JSON INPUT ---
      APEX_JSON.parse(P_JSON);
      
      -- EXTRACT VALUES FROM JSON USING APEX_JSON---
      V_ACCOUNT_NUMBER := APEX_JSON.get_varchar2('BANK_ACCOUNT.ACCOUNT_NUMBER');
      V_ACCOUNT_NAME := APEX_JSON.get_varchar2('BANK_ACCOUNT.ACCOUNT_NAME');
      V_BALANCE := APEX_JSON.get_number('BANK_ACCOUNT.BALANCE');
      
            --INSERTING THE EXTRACTED DATA INTO THE BANK_ACCOUNTS TABLE--
     INSERT INTO BANK_ACCOUNTS(ACCOUNT_NUMBER, ACCOUNT_NAME, BALANCE)
     VALUES(V_ACCOUNT_NUMBER, V_ACCOUNT_NAME, V_BALANCE);
     
     
     DBMS_OUTPUT.PUT_LINE('ACCOUNT CREATED SUCCESSFULLY!'||V_ACCOUNT_NUMBER);
     
     EXCEPTION
     
      WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR!'||SQLERRM);
      
    END;
    /
    
    DECLARE 
    
    V_JSON CLOB := '{"BANK_ACCOUNT" : {"ACCOUNT_NUMBER": "ACC011", "ACCOUNT_NAME": "Michael Bright", "BALANCE": 1500}}';

    BEGIN 
    
   CREATE_ACCOUNTS_FROM_JSON (V_JSON);
   
   END;
   
   SELECT * FROM BANK_ACCOUNTS;
   
   
    
    
    
    
    
    
    
    
    
    
--8. Generating JSON Output of All Accounts (15 Marks)
--Write a function get_all_accounts_json RETURN CLOB that returns a JSON string of all bank accounts using
--APEX_JSON.
--Expected Output Format:
--{
--"accounts": [
--{"account_number": "ACC001", "account_name": "Alice Martins", "balance": 6000},
--{"account_number": "ACC002", "account_name": "John Peters", "balance": 3000}
--]
--}

    CREATE OR REPLACE FUNCTION GET_ALL_ACCOUNTS_JSON
    RETURN CLOB
    AS
    
    V_JSON_GET_ACCOUNT CLOB;
    
    V_ACCOUNT_NUMBER VARCHAR2(10);
    V_ACCOUNT_NAME VARCHAR2(100);
    V_BALANCE NUMBER;
    
    BEGIN
    
    APEX_JSON.INITIALIZE_CLOB_OUTPUT;
    
    APEX_JSON.OPEN_OBJECT;
    APEX_JSON.OPEN_ARRAY('ACCOUNTS');
    
    FOR GET_ACCOUNT IN (SELECT ACCOUNT_NUMBER, ACCOUNT_NAME, BALANCE FROM BANK_ACCOUNTS)LOOP
    APEX_JSON.OPEN_OBJECT;
    APEX_JSON.WRITE('ACCOUNT_NUMBER', GET_ACCOUNT.ACCOUNT_NUMBER);
    APEX_JSON.WRITE('ACCOUNT_NAME', GET_ACCOUNT.ACCOUNT_NAME);
    APEX_JSON.WRITE('BALANCE', GET_ACCOUNT.BALANCE);
    APEX_JSON.CLOSE_OBJECT;
    END LOOP;
    
    APEX_JSON.CLOSE_ARRAY;
    APEX_JSON.CLOSE_OBJECT;
    
    V_JSON_GET_ACCOUNT := APEX_JSON.GET_CLOB_OUTPUT;
    APEX_JSON.FREE_OUTPUT;
    
    RETURN V_JSON_GET_ACCOUNT;
    END;
    /
    
    

    DECLARE
    
    V_JSON_GET_ACCOUNT CLOB;
    
    BEGIN
    
    V_JSON_GET_ACCOUNT := GET_ALL_ACCOUNTS_JSON;
    
    DBMS_OUTPUT.PUT_LINE( V_JSON_GET_ACCOUNT);
    
    END;
    /
    
    
    
    
--9. Generating JSON Output of All Accounts (20 Marks)
--You called an endpoint successfully with the following response
--{
--"ResponseCode":200,
--"Message":"Success",
--"TotalRows":10,
--"RowsInserted":6,
--"TrxInserted":"1311894,1311827,1309233,1309571,1312002,1310298",
--"RowsNotInserted":4,
--"TrxNotInserted":"1312249,1312566,1311693,1312610",
--}
--Write a procedure the gets the “TrxInserted” and “TrxNotInserted” keys and log them intosame table while
--identifying which was inserted and which id did not insert.


CREATE TABLE LOG_TRANSACTION(
TRXN_ID VARCHAR2(10),
LOG_STATUS VARCHAR2(1000),
LOG_DATE DATE
);

CREATE OR REPLACE PROCEDURE INSERT_JSON_LOG_TRXN(P_JSON IN CLOB)AS

V_STRING VARCHAR2(1000);
--V_TRXN_INSERTED VARCHAR2(1000);
--V_TRXN_NOT_INSERTED VARCHAR2(1000);
TEMP_STR VARCHAR2(100);
REF_POS NUMBER;
REF_NEXT NUMBER;

BEGIN 

APEX_JSON.parse(P_JSON);

V_STRING := APEX_JSON.GET_VARCHAR2('TrxInserted');

IF V_STRING IS NOT NULL THEN
REF_POS := 1;
LOOP
REF_NEXT := INSTR(V_STRING, ',', REF_POS);
IF REF_NEXT = 0 THEN
TEMP_STR := TRIM(SUBSTR(V_STRING, REF_POS));
ELSE
TEMP_STR := TRIM(SUBSTR(V_STRING, REF_POS, REF_NEXT - REF_POS));
END IF;
 EXIT WHEN TEMP_STR IS NULL;
 
 INSERT INTO LOG_TRANSACTION(TRXN_ID, LOG_STATUS, LOG_DATE) VALUES (TEMP_STR, 'INSERTED', SYSDATE);

EXIT WHEN REF_NEXT = 0;
REF_POS := REF_NEXT + 1;
END LOOP;
END IF;


V_STRING := APEX_JSON.GET_VARCHAR2('TrxNotInserted');
IF V_STRING IS NOT NULL THEN
REF_POS := 1;
LOOP
REF_NEXT := INSTR(V_STRING, ',' , REF_POS);
IF  REF_NEXT = 0 THEN
TEMP_STR := TRIM(SUBSTR(V_STRING, REF_POS));
ELSE
TEMP_STR := TRIM(SUBSTR(V_STRING, REF_POS, REF_NEXT - REF_POS));
END IF;
EXIT WHEN TEMP_STR IS NULL;

INSERT INTO LOG_TRANSACTION(TRXN_ID, LOG_STATUS, LOG_DATE) VALUES (TEMP_STR, 'NOT INSERTED', SYSDATE);
EXIT WHEN REF_NEXT = 0;
REF_POS := REF_NEXT + 1;

END LOOP;
END IF;

DBMS_OUTPUT.PUT_LINE('TRANSACTION IDs LOGGED SUCCESSFULLY');

EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR'|| SQLERRM);
END;
/


DECLARE

V_JSON CLOB :=

'{
  "ResponseCode":200,
  "Message":"Success",
  "TotalRows":10,
  "RowsInserted":6,
  "TrxInserted":"1311894,1311827,1309233,1309571,1312002,1310298",
  "RowsNotInserted":4,
  "TrxNotInserted":"1312249,1312566,1311693,1312610"
  }';
  
  BEGIN
  INSERT_JSON_LOG_TRXN(v_json);
END;
/
  

-- SELECT * FROM LOG_TRANSACTION





















































