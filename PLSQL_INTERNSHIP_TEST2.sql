--Section A – Core PL/SQL (100 Marks)
--Note: These tasks assess core PL/SQL skills including procedure writing, cursors, triggers, exception handling,
--and transactions.

--1. Procedure – Fund Transfer (20 Marks)
--Write a procedure transfer_funds(p_from_acct IN VARCHAR2, p_to_acct IN VARCHAR2, p_amount IN
--NUMBER) to transfer funds between two accounts. Ensure:
--- Validation: Both accounts exist.
--- Sufficient balance.
--- Atomic transaction with rollback on failure.

CREATE OR REPLACE PROCEDURE TRANSFER_FUNDS
(P_FROM_ACCOUNT IN VARCHAR2, P_TO_ACCOUNT IN VARCHAR2, P_AMOUNT IN NUMBER, P_MSG OUT VARCHAR2) 

AS

V_BALANCE NUMBER(10,2);
V_FROM_ACCOUNT VARCHAR2(10);
V_TO_ACCOUNT VARCHAR2(10);
V_MSG VARCHAR2(100);
V_TO_COUNT NUMBER;
V_FROM_COUNT NUMBER;


BEGIN

SELECT COUNT(*)INTO V_FROM_COUNT FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;

SELECT BALANCE INTO V_BALANCE
FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;


IF V_FROM_COUNT > 0 AND V_BALANCE > 0 THEN 

UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE - P_AMOUNT 
WHERE ACCOUNT_NUMBER = P_FROM_ACCOUNT;
--COMMIT;

V_BALANCE := V_BALANCE - P_AMOUNT;

P_MSG := 'AN AMOUNT OF' ||V_BALANCE|| 'HAS BEEN DEDUCTED FROM YOUR ACCOUNT.';
 
COMMIT; 
 
ELSE 

ROLLBACK;

P_MSG := 'CURRENT BALANCE IS: '||V_BALANCE;

END IF;

 
SELECT COUNT(*)INTO V_TO_COUNT FROM BANK_ACCOUNTS 
WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 
 SELECT BALANCE INTO V_BALANCE 
FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 
  IF V_TO_COUNT> 0  THEN 
 
 UPDATE BANK_ACCOUNTS
 SET BALANCE = BALANCE + P_AMOUNT
 WHERE ACCOUNT_NUMBER = P_TO_ACCOUNT;
 COMMIT;
 
  P_MSG := 'YOUR ACCOUNT WAS SUCCESSFULLY CREDITED';
  
  ELSE
  
  ROLLBACK;

 END IF;
 
 
 EXCEPTION

 WHEN NO_DATA_FOUND THEN
 P_MSG := 'ACCOUNT NOT FOUND';
 WHEN OTHERS THEN
 P_MSG := 'UNEXPECTED ERROR!'||SQLERRM;
 END;
 /
 
 DECLARE 
 
 V_FROM_ACCOUNT VARCHAR(20);
 V_TO_ACCOUNT VARCHAR2(10);
 V_AMOUNT NUMBER;
 V_MSG VARCHAR2(100);
 
 
 BEGIN
 
 TRANSFER_FUNDS
('ACC002', 'ACC001', 500, V_MSG);

DBMS_OUTPUT.PUT_LINE(V_MSG);

END;
/



--SELECT * FROM BANK_ACCOUNTS;



--2. Function – Account Summary (10 Marks)
--Create a function get_account_summary(p_acct_no IN VARCHAR2) RETURN VARCHAR2 that returns a string
--summary of account name and balance.

CREATE OR REPLACE FUNCTION GET_ACCOUNT_SUMMARY(P_ACCOUNT_NUMBER IN VARCHAR2)
RETURN VARCHAR2
AS
V_ACCOUNT_SUMMARY VARCHAR(100);
V_ACCOUNT_NAME VARCHAR2(100); 
V_ACCOUNT_NUMBER VARCHAR2(100);
V_BALANCE NUMBER(10,2);

BEGIN

SELECT ACCOUNT_NUMBER, ACCOUNT_NAME, BALANCE INTO V_ACCOUNT_NUMBER, 
V_ACCOUNT_NAME, V_BALANCE FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

V_ACCOUNT_SUMMARY := V_ACCOUNT_NUMBER ||'  '|| V_ACCOUNT_NAME ||'  '|| V_BALANCE;

--DBMS_OUTPUT.PUT_LINE(V_ACCOUNT_SUMMARY);

RETURN V_ACCOUNT_SUMMARY;

END;

/



DECLARE

V_ACCOUNT_SUMMARY VARCHAR2(100);

BEGIN
V_ACCOUNT_SUMMARY := GET_ACCOUNT_SUMMARY('ACC001');

DBMS_OUTPUT.PUT_LINE(V_ACCOUNT_SUMMARY);
END;
/


--3. Cursor – Calculate Interest (15 Marks)
--Use an explicit cursor to iterate through accounts and increase their balance by 5% interest. Use a FOR LOOP
--and UPDATE statement.


Declare
Cursor int_cursor is 
select  account_number, balance from bank_accounts;

bank_interest  bank_accounts%rowtype;

begin
 
 FOR bank_interest in int_cursor LOOP
    select count(*)into v_account from bank_accounts
    where account_number = bank_interest.Account_number;
    
    if v_account > 0 then
    update bank_accounts
    set balance = balance + balance * 0.05;
    dbms_output.put_line('Account '||bank_interest.Account_number|| ' exists. ');
    else
    dbms_output.put_line('Account '||bank_interest.Account_number|| ' does not exists. ');
    end if;
    end loop;
    end;
    /


DECLARE 

CURSOR BANK_INTEREST IS 
SELECT ACCOUNT_NUMBER, BALANCE FROM BANK_ACCOUNTS;


V_ACCOUNT_NUMBER  BANK_ACCOUNTS.ACCOUNT_NUMBER%TYPE;
V_BALANCE   BANK_ACCOUNTS.BALANCE%TYPE;

--V_COUNT NUMBER;

BEGIN 
FOR  BANK_REC IN  BANK_INTEREST LOOP

--SELECT COUNT(*) INTO V_COUNT FROM BANK_ACCOUNTS
--WHERE ACCOUNT_NUMBER = BANK_REC.ACCOUNT_NUMBER;

--IF V_COUNT > 0 THEN

UPDATE BANK_ACCOUNTS
SET BALANCE = BALANCE + BALANCE*0.05
WHERE ACCOUNT_NUMBER = BANK_REC.ACCOUNT_NUMBER;

DBMS_OUTPUT.PUT_LINE('ACCOUNT UPDATED SUCCESSFULLY!');

END LOOP;

EXCEPTION 
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR'||SQLERRM);

END;
/

--SELECT * FROM BANK_ACCOUNTS

--4. Trigger – Audit Transactions (20 Marks)
--Write a trigger trg_audit_transaction that captures any UPDATE on balance and inserts into a table
--account_audit_log(account_number, old_balance, new_balance, modified_on).

CREATE TABLE ACCOUNT_AUDIT_LOG(
ACCOUNT_NUMBER VARCHAR2(10) PRIMARY KEY,
OLD_BALANCE NUMBER(10,2),
NEW_BALANCE NUMBER(10,2),
MODIFIED_ON DATE
);


CREATE OR REPLACE TRIGGER TRG_AUDIT_TRANSACTION
BEFORE UPDATE OF BALANCE ON BANK_ACCOUNTS
FOR EACH ROW 
DECLARE 
V_BALANCE NUMBER(10,2);


BEGIN
IF INSERTING THEN
INSERT INTO ACCOUNT_AUDIT_LOG(ACCOUNT_NUMBER, OLD_BALANCE, NEW_BALANCE, MODIFIED_ON)
VALUES(:NEW.ACCOUNT_NUMBER, NULL, :NEW.BALANCE, SYSDATE);

ELSIF UPDATING THEN
INSERT INTO ACCOUNT_AUDIT_LOG (ACCOUNT_NUMBER, OLD_BALANCE, NEW_BALANCE, MODIFIED_ON)
VALUES(:OLD.ACCOUNT_NUMBER, :OLD.BALANCE, :NEW.BALANCE, SYSDATE);
END IF;

EXCEPTION

WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR!' || SQLERRM);
END;


--5. Exception Handling – Minimum Balance Check (15 Marks)
--Write a procedure withdraw(p_account_no IN VARCHAR2, p_amount IN NUMBER) that throws a custom
--exception if the remaining balance goes below 1000.

CREATE OR REPLACE PROCEDURE MINIMUM_BALANCE_CHECK(P_ACCOUNT_NUMBER IN VARCHAR2, P_AMOUNT IN NUMBER)
AS

V_ACCOUNT_NUMBER VARCHAR2(100);
V_AMOUNT NUMBER;

BEGIN

SELECT ACCOUNT_NUMBER, BALANCE INTO V_ACCOUNT_NUMBER, V_AMOUNT FROM BANK_ACCOUNTS
WHERE ACCOUNT_NUMBER = P_ACCOUNT_NUMBER;

IF V_ACCOUNT_NUMBER > 0 AND V_AMOUNT <= 1000 THEN

DBMS_OUTPUT.PUT_LINE('YOU ACCOUNT BALANCE IS TOO LOW FOR WITHDRAWAL' || V_AMOUNT);

END IF;

EXCEPTION 

WHEN OTHERS THEN 
DBMS_OUTPUT.PUT_LINE('UNEXPECTED ERROR: '|| SQLERRM);
END;
/

DECLARE

V_ACCOUNT_NUMBER VARCHAR2(10);
V_AMOUNT NUMBER(10,2);

BEGIN

MINIMUM_BALANCE_CHECK('ACC001', 2000 );

DBMS_OUTPUT.PUT_LINE('YOUR ACCOUNT BALANCE IS TOO LOW TO MAKE A WITHDARWAL');

END;
/


--6. Conceptual Questions (20 Marks)
--- What is the difference between %ROWTYPE and %TYPE?

---THE %ROWTYPE CONTAINS THE ENTIRE DATATYPE OF THE ROW RECORD AND 
--THE %TYPE IS JUST FOR A SINGLE RECORD OF AN ATTRIBUTE 
--AN EXAMPLE OF THE ROWTYPE IS FOR EXAMPLE THE EMPLOYEES TABLE. IT COVERS THE 
--DATATYPE OF THE EMPLOYEE ID, FIRST NAME, LAST NAME ETC AND IF I WOULD LATER CREATE ANOTHER 
--TABLE I WOULDNT NEED TO DECLARE THE ENTIRE THING AGAIN, I WOULD SIMPLE USE THE %ROWTYPE
--EXAMPLE    v_employee employees%ROWTYPE;



--THE %TYPE ONLY HOLDS THE TYPE FOR A PARTICULAR ATTRIBUTE AND NOT A RECORD. 
-- FOR EXAMPLE V_ACCOUNT_NUMBER BANK_ACCOUNTS.ACCOUNT_NUMBER%TYPE


--- What is the purpose of AUTONOMOUS_TRANSACTION?

--STORED PROCEDURES AND FUNCTIONS ARE EXAMPLES OF AUTONOMOUS FUNCTIONS 
--AS THE NAME IMPLIES THERE ARE INDEPENDENT OF MAKING TRANSACTIONS. IF ANOTHER TRANSACTION CALLS AN
--AUTONOMOUS TRANSACTION IS IT IS NOT AFFECTED BY IT BECAUSE ONLY COMMITTED TRANSACTIONS CAN INTERACT.
--EXAMPLE A CHILD CODE RUNNING INDEPENDENTLY OF THE PARENT CODE 

--IF WE WANT TRANSACTIONS TO BE INDEPENDENT AND NOT BE AFFECT BY COMMITS OR ROLLBACKS FROM OTHER 
--TRANSACTIONS, IT IS BEST TO USE AUTONOMOUS TRANSACTION. IT KEEPS A TRANSACTION FROM EXTERNAL INFLUENCES


--- Explain SAVEPOINT and ROLLBACK TO SAVEPOINT.

--SAVE POINTS ARE LOGICAL POINTS WITHIN A STATEMENT THAT A TRANSACTION ROLL'S BACK TO 
 -- ROLLBACK TO SAVEPOINTS ROLLBACK THE TRANSACTION TO THE PREVIOUS SSAVE POINTS
 
 --IF I MAKE THREE INSERT STATEMENTS AND THEN SAVE TRANSACTIONS, THAT IS A SAFEPOINT
 --IF I AGAIN INSERT THREE RECORDS AND AND SAVE IT, AND IF I ROLLBACK, IT TAKE, IT BACK TO 
 --FIRST THREE RECORD THAT WAS INSERTED. THIS SAVE TRANSACTION POINTS ARE VERY IMPORTANT WHEN.
 --IT HELPS TO MAINTAIN THE ACID PROPERTY OF A DATABASE 
 
--- Difference between IN, OUT, and IN OUT parameters?

--IN IS A DEFAULT MODE PASSES VALUE TO THE SUBPROGRAM
--IS PASSED BY REFERENCE - NOT DIRECTLY

--OUT IS SPECIFIC, IT MUST BE SPECIFIED, SAME AS IN OUT

--IN OUT FIRST PASSES A VALUE TO THE SUBPROGRAM AND THEN 
--AND UPDATED VALUE TO THE CALLER 